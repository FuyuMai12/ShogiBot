from random import Random
from typing import Callable, List, Tuple

from boards.board import ShogiBoard
from const.gameplay import Player
from const.models import (
    choose_from_probability_list,
    softmax
)


class ShogiGeneticAlgorithmBaseBot:
    def __init__(self, seed: int = 21212,
                 value_lower: float = -10.0,
                 value_upper: float = 10.0,
                 gene_specs: dict[str, float] = None,
                 gene_names: List[str] = None):
        """
        Constructor

        Arguments:
        - seed (int):
            Seed of the bot's RNG
        - value_lower (float):
            Lower bound value of a gene
        - value_upper (float):
            Upper bound value of a gene
        - gene_specs (dict[str, float]):
            Specification of genes and their values. Take higher priority than gene_names.
        - gene_names (List[str]):
            List of gene names, their values will be randomly generated by the bot's RNG
        """
        self.seed = seed
        self.range = (value_lower, value_upper)
        self.rng = Random(self.seed)

        self.genes = gene_specs
        if gene_specs is None:
            self.genes = {}
            for gene_name in gene_names:
                self.genes[gene_name] = self.rng.uniform(self.range[0], self.range[1])

    # end __init__()

    def possible_actions(self, bot_side: Player, board: ShogiBoard) -> List[Tuple[dict, float]]:
        """
        List the possible actions of the bot given the current board
        This function should be overriden by each variant of the explicit bot model

        Arguments:
        - bot_side (Player): the side the bot is in
        - board (ShogiBoard): the current shogi board

        Returns:
            List[Tuple[dict, float]]:
                A list of possible actions (in the form of a dict) and the according value/advantage
                that action added to the bot (that value could be negative, of course).
        """
        raise NotImplementedError

    # end __possible_actions()

    def make_action(self, bot_side: Player, board: ShogiBoard,
                    decision_algorithm: Callable = softmax):
        """
        Make an action based on the current board

        Arguments:
        - bot_side (Player):
            The side the bot is in
        - board (ShogiBoard):
            The current shogi board
        - decision_function (function):
            The function used to determine the probability to choose each action
            Defaults: const.models.softmax
        """
        possible_actions = self.possible_actions(bot_side, board)
        actions_raw = [action for action, _ in possible_actions]
        values_raw = [value for _, value in possible_actions]
        probabilities_raw = decision_algorithm(values_raw)

        chosen_action = actions_raw[choose_from_probability_list(
            probability_list=probabilities_raw,
            rng=self.rng
        )]

        board.perform_action(action_dict=chosen_action)

    # end make_action()

    def crossover(self, other, system_rng: Random):
        """
        Cross-mating two models, resulting in two new offsprings

        Arguments:
        - other:
            Another model
        - system_rng (random.Random):
            A random number generator used by the system (not the bot)
        """
        assert(type(self) is type(other))

        gene_names = list(self.genes.keys())
        offspring1_bitmask = system_rng.randrange(0, 2 ** len(gene_names))
        offspring2_bitmask = (2 ** len(gene_names) - 1) ^ offspring1_bitmask

        new_genes_1 = {
            self.genes[gene_name]
            if ((offspring1_bitmask >> index) & 1) > 0
            else other.genes[gene_name]
            for index, gene_name in enumerate(gene_names)
        }
        new_genes_2 = {
            self.genes[gene_name]
            if ((offspring2_bitmask >> index) & 1) > 0
            else other.genes[gene_name]
            for index, gene_name in enumerate(gene_names)
        }

        offspring1 = type(self)(
            seed=self.seed,
            value_lower=self.range[0],
            value_upper=self.range[1],
            gene_specs=new_genes_1
        )

        offspring2 = type(self)(
            seed=other.seed,
            value_lower=other.range[0],
            value_upper=other.range[1],
            gene_specs=new_genes_2
        )

        return (offspring1, offspring2)

    # end mutate_reinit()

    def mutate_reinit(self,
                      mutating_chance: float,
                      variation_intensity: float,
                      system_rng: Random):
        """
        Mutate a model using re-initialization of genes

        Arguments:
        - mutating_chance (float):
            Chance for a gene to mutate
        - variation_intensity (float):
            Variation range of a mutating gene. If genes have valid range of [x, y],
            one mutating gene has a value of z and the variation intensity is v, then
            the new value would be randomly taken from this range:
                [max(x, z - (y-x) * v), min(z + (y-x) * v, y)]
        - system_rng (random.Random):
            A random number generator used by the system (not the bot)
        """
        new_genes = {}
        for gene in self.genes:
            if system_rng.random() <= mutating_chance:
                new_genes[gene] = system_rng.uniform(
                    max(self.range[0],
                        self.genes[gene] - (self.range[1] - self.range[0]) * variation_intensity),
                    min(self.genes[gene] + (self.range[1] - self.range[0]) * variation_intensity,
                        self.range[1])
                )
            else:
                new_genes[gene] = self.genes[gene]

        return type(self)(
            seed=self.seed,
            value_lower=self.range[0],
            value_upper=self.range[1],
            gene_specs=new_genes
        )

    # end mutate_reinit()

    def mutate_swap(self,
                    mutating_chance: float,
                    swapping_attempt: int,
                    system_rng: Random):
        """
        Mutate a model using value swaps of genes

        Arguments:
        - mutating_chance (float):
            Chance for a gene to mutate
        - swapping_attempt (int):
            Number of attempts to swap genes' values
        - system_rng (random.Random):
            A random number generator used by the system (not the bot)
        """
        new_genes = {gene: self.genes[gene] for gene in self.genes}
        gene_names = list(new_genes.keys())
        for _ in swapping_attempt:
            if system_rng.random() <= mutating_chance:
                gene_1, gene_2 = system_rng.sample(gene_names, 2)
                new_genes[gene_1], new_genes[gene_2] = new_genes[gene_2], new_genes[gene_1]

        return type(self)(
            seed=self.seed,
            value_lower=self.range[0],
            value_upper=self.range[1],
            gene_specs=new_genes
        )

    # end mutate_reinit()

    def __repr__(self):
        return f"<{type(self)} with seed={self.seed}>"

    # end __repr__()

# end ShogiGeneticAlgorithmBaseBot
